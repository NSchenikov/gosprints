Спринт 3: Уведомления в реальном времени через WebSocket

Задача:

    Добавить возможность пользователю получать уведомления о прогрессе задач в реальном времени.
    При обновлении статуса задачи «воркер» должен через WebSocket-соединение отправлять событие тому пользователю, чья задача обновилась.
    Продумать структуру сообщений (например, в формате JSON), чтобы легко расширять в будущем.

Цели:

    Освоить работу с WebSocket-соединениями в Go (подключение, чтение/запись, обработка отключений).
    Научиться связывать очередь обработки и WebSocket-уведомления.
    Изучить подходы к масштабированию WebSocket-сервисов (какой-нибудь пример с load balancing и Sticky Sessions, хотя бы теоретически).

Функциональные требования:

    WebSocket-соединения:
        Реализовать эндпоинт для подключения клиентов по WebSocket (например, /ws).
        При изменении статуса задачи воркер отправляет уведомление подключенному пользователю.
    Формат сообщений:
        JSON-сообщения, содержащие: идентификатор задачи, новый статус, временную метку, возможно, краткую информацию о задаче.
    Интеграция с основным сервисом:
        Встроить механизм уведомлений в логику обработки задач.

Нефункциональные требования:

    Обеспечение стабильности WebSocket-соединений и корректная обработка отключений.
    Проработка масштабируемости: при большом числе подключенных клиентов возможна интеграция с балансировщиками и решением вопросов sticky sessions.

        __________________________
        1) вынести создание роутера в отдельную функцию (handle в том числе). Для красоты +
        2) убрать постановку задач в очередь из хэндлера getTasks. Создать еще один воркер в количестве одной горутины. Внутри использовать ticker из пакета time. По ticker через репозиторий получать список тасок с определенными статусами. Таски класть в очередь на обработку +
        3) добавить слой бизнес-логики (сервис app или useCase). Слой должен быть архитектурно между хэндлерами и репозиториями +
        4) (погуглить). Реализовать graceful shootdown - завершить контекстом все запущенные воркеры (с cancel) +
        5)* использовать интерфейсы вместо конкретных структур (везде). Интерфейсы объявлять в месте использования, а не реализации
        6) написать тест на воркер, который меняет статусы (проверить действительно ли меняются статусы)
        7) Перенести интерфейс туда, где он используется: интерфейс TaskService перенести в хэндлер (аналогично с репозиторием. Перенести в сервис)