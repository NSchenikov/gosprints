Спринт 4: Кеширование и метрики

Задача:

    Кеширование:
        Кэшировать популярные запросы к задачам (например, список новых задач) либо детальные данные по задаче.
        Можно хранить кеш в памяти (например, с помощью sync.Map) или в Redis — если хочется. Redis так же можно запустить докером.
        Настроить механизм протухания (TTL).
    Метрики:
        Собрать ключевые метрики: количество задач, среднее время обработки, число активных WebSocket-соединений.
        Реализовать эндпоинт /metrics для отдачи данных в JSON или формате, удобном для интеграции с Prometheus.



Спринт 5: Расширение функционала – Поиск, метрики и gRPC

Функциональные требования:

    Поиск по задачам:
        Реализовать эндпоинт GET /search?query=... для поиска по полям title и description.
        Настроить полнотекстовый поиск PostgreSQL, создать соответствующие индексы.

    gRPC-сервис:
        Создать базовый gRPC-сервис для операций с задачами (например, методы CreateTask, GetTask, ListTasks).
        Использовать gRPC для внутренней коммуникации между компонентами (например, между API-шлюзом и микросервисом обработки задач).

        __________________________
        К третьему спринту: 
        1) при повторном подключении user к ws что происходит со старым conn? Зависает, создавая утечку памяти или детектор дисконнекта в хэндлере может удалить новое подключение?
        Ответ: Клиент открывает новый WebSocket, NewWSHandler создаёт новый conn. AddClient заменяет старый conn на новый, но не закрывает его. Старый conn продолжает существовать в памяти, а хэндлер всё ещё висит в for { ReadMessage() }. Старая горутина не завершится. RemoveClient срабатывает только когда хэндлер получает ошибку